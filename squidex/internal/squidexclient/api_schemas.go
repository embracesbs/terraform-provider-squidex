/*
Squidex API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 7.0.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// SchemasApiService SchemasApi service
type SchemasApiService service

type ApiSchemaFieldsDeleteFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	id int64
}

func (r ApiSchemaFieldsDeleteFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsDeleteFieldExecute(r)
}

/*
SchemaFieldsDeleteField Delete a schema field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param id The id of the field to disable.
 @return ApiSchemaFieldsDeleteFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsDeleteField(ctx context.Context, app string, schema string, id int64) ApiSchemaFieldsDeleteFieldRequest {
	return ApiSchemaFieldsDeleteFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsDeleteFieldExecute(r ApiSchemaFieldsDeleteFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsDeleteField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsDeleteNestedFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	id int64
}

func (r ApiSchemaFieldsDeleteNestedFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsDeleteNestedFieldExecute(r)
}

/*
SchemaFieldsDeleteNestedField Delete a nested field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @param id The id of the field to disable.
 @return ApiSchemaFieldsDeleteNestedFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsDeleteNestedField(ctx context.Context, app string, schema string, parentId int64, id int64) ApiSchemaFieldsDeleteNestedFieldRequest {
	return ApiSchemaFieldsDeleteNestedFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsDeleteNestedFieldExecute(r ApiSchemaFieldsDeleteNestedFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsDeleteNestedField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsDisableFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	id int64
}

func (r ApiSchemaFieldsDisableFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsDisableFieldExecute(r)
}

/*
SchemaFieldsDisableField Disable a schema field.

A disabled field cannot not be edited in the squidex portal anymore, but will be part of the API response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param id The id of the field to disable.
 @return ApiSchemaFieldsDisableFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsDisableField(ctx context.Context, app string, schema string, id int64) ApiSchemaFieldsDisableFieldRequest {
	return ApiSchemaFieldsDisableFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsDisableFieldExecute(r ApiSchemaFieldsDisableFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsDisableField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{id}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsDisableNestedFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	id int64
}

func (r ApiSchemaFieldsDisableNestedFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsDisableNestedFieldExecute(r)
}

/*
SchemaFieldsDisableNestedField Disable a nested field.

A disabled field cannot not be edited in the squidex portal anymore, but will be part of the API response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @param id The id of the field to disable.
 @return ApiSchemaFieldsDisableNestedFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsDisableNestedField(ctx context.Context, app string, schema string, parentId int64, id int64) ApiSchemaFieldsDisableNestedFieldRequest {
	return ApiSchemaFieldsDisableNestedFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsDisableNestedFieldExecute(r ApiSchemaFieldsDisableNestedFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsDisableNestedField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsEnableFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	id int64
}

func (r ApiSchemaFieldsEnableFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsEnableFieldExecute(r)
}

/*
SchemaFieldsEnableField Enable a schema field.

A disabled field cannot not be edited in the squidex portal anymore, but will be part of the API response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param id The id of the field to enable.
 @return ApiSchemaFieldsEnableFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsEnableField(ctx context.Context, app string, schema string, id int64) ApiSchemaFieldsEnableFieldRequest {
	return ApiSchemaFieldsEnableFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsEnableFieldExecute(r ApiSchemaFieldsEnableFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsEnableField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{id}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsEnableNestedFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	id int64
}

func (r ApiSchemaFieldsEnableNestedFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsEnableNestedFieldExecute(r)
}

/*
SchemaFieldsEnableNestedField Enable a nested field.

A disabled field cannot not be edited in the squidex portal anymore, but will be part of the API response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @param id The id of the field to enable.
 @return ApiSchemaFieldsEnableNestedFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsEnableNestedField(ctx context.Context, app string, schema string, parentId int64, id int64) ApiSchemaFieldsEnableNestedFieldRequest {
	return ApiSchemaFieldsEnableNestedFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsEnableNestedFieldExecute(r ApiSchemaFieldsEnableNestedFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsEnableNestedField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsHideFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	id int64
}

func (r ApiSchemaFieldsHideFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsHideFieldExecute(r)
}

/*
SchemaFieldsHideField Hide a schema field.

A hidden field is not part of the API response, but can still be edited in the portal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param id The id of the field to hide.
 @return ApiSchemaFieldsHideFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsHideField(ctx context.Context, app string, schema string, id int64) ApiSchemaFieldsHideFieldRequest {
	return ApiSchemaFieldsHideFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsHideFieldExecute(r ApiSchemaFieldsHideFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsHideField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{id}/hide"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsHideNestedFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	id int64
}

func (r ApiSchemaFieldsHideNestedFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsHideNestedFieldExecute(r)
}

/*
SchemaFieldsHideNestedField Hide a nested field.

A hidden field is not part of the API response, but can still be edited in the portal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @param id The id of the field to hide.
 @return ApiSchemaFieldsHideNestedFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsHideNestedField(ctx context.Context, app string, schema string, parentId int64, id int64) ApiSchemaFieldsHideNestedFieldRequest {
	return ApiSchemaFieldsHideNestedFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsHideNestedFieldExecute(r ApiSchemaFieldsHideNestedFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsHideNestedField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/hide"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsLockFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	id int64
}

func (r ApiSchemaFieldsLockFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsLockFieldExecute(r)
}

/*
SchemaFieldsLockField Lock a schema field.

A locked field cannot be updated or deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param id The id of the field to lock.
 @return ApiSchemaFieldsLockFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsLockField(ctx context.Context, app string, schema string, id int64) ApiSchemaFieldsLockFieldRequest {
	return ApiSchemaFieldsLockFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsLockFieldExecute(r ApiSchemaFieldsLockFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsLockField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{id}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsLockNestedFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	id int64
}

func (r ApiSchemaFieldsLockNestedFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsLockNestedFieldExecute(r)
}

/*
SchemaFieldsLockNestedField Lock a nested field.

A locked field cannot be edited or deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @param id The id of the field to lock.
 @return ApiSchemaFieldsLockNestedFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsLockNestedField(ctx context.Context, app string, schema string, parentId int64, id int64) ApiSchemaFieldsLockNestedFieldRequest {
	return ApiSchemaFieldsLockNestedFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsLockNestedFieldExecute(r ApiSchemaFieldsLockNestedFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsLockNestedField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsPostFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	addFieldDto *AddFieldDto
}

// The field object that needs to be added to the schema.
func (r ApiSchemaFieldsPostFieldRequest) AddFieldDto(addFieldDto AddFieldDto) ApiSchemaFieldsPostFieldRequest {
	r.addFieldDto = &addFieldDto
	return r
}

func (r ApiSchemaFieldsPostFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsPostFieldExecute(r)
}

/*
SchemaFieldsPostField Add a schema field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemaFieldsPostFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsPostField(ctx context.Context, app string, schema string) ApiSchemaFieldsPostFieldRequest {
	return ApiSchemaFieldsPostFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsPostFieldExecute(r ApiSchemaFieldsPostFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsPostField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addFieldDto == nil {
		return localVarReturnValue, nil, reportError("addFieldDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addFieldDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsPostNestedFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	addFieldDto *AddFieldDto
}

// The field object that needs to be added to the schema.
func (r ApiSchemaFieldsPostNestedFieldRequest) AddFieldDto(addFieldDto AddFieldDto) ApiSchemaFieldsPostNestedFieldRequest {
	r.addFieldDto = &addFieldDto
	return r
}

func (r ApiSchemaFieldsPostNestedFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsPostNestedFieldExecute(r)
}

/*
SchemaFieldsPostNestedField Add a nested field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @return ApiSchemaFieldsPostNestedFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsPostNestedField(ctx context.Context, app string, schema string, parentId int64) ApiSchemaFieldsPostNestedFieldRequest {
	return ApiSchemaFieldsPostNestedFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsPostNestedFieldExecute(r ApiSchemaFieldsPostNestedFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsPostNestedField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addFieldDto == nil {
		return localVarReturnValue, nil, reportError("addFieldDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addFieldDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsPutFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	id int64
	updateFieldDto *UpdateFieldDto
}

// The field object that needs to be added to the schema.
func (r ApiSchemaFieldsPutFieldRequest) UpdateFieldDto(updateFieldDto UpdateFieldDto) ApiSchemaFieldsPutFieldRequest {
	r.updateFieldDto = &updateFieldDto
	return r
}

func (r ApiSchemaFieldsPutFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsPutFieldExecute(r)
}

/*
SchemaFieldsPutField Update a schema field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param id The id of the field to update.
 @return ApiSchemaFieldsPutFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsPutField(ctx context.Context, app string, schema string, id int64) ApiSchemaFieldsPutFieldRequest {
	return ApiSchemaFieldsPutFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsPutFieldExecute(r ApiSchemaFieldsPutFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsPutField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsPutNestedFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	id int64
	updateFieldDto *UpdateFieldDto
}

// The field object that needs to be added to the schema.
func (r ApiSchemaFieldsPutNestedFieldRequest) UpdateFieldDto(updateFieldDto UpdateFieldDto) ApiSchemaFieldsPutNestedFieldRequest {
	r.updateFieldDto = &updateFieldDto
	return r
}

func (r ApiSchemaFieldsPutNestedFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsPutNestedFieldExecute(r)
}

/*
SchemaFieldsPutNestedField Update a nested field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @param id The id of the field to update.
 @return ApiSchemaFieldsPutNestedFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsPutNestedField(ctx context.Context, app string, schema string, parentId int64, id int64) ApiSchemaFieldsPutNestedFieldRequest {
	return ApiSchemaFieldsPutNestedFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsPutNestedFieldExecute(r ApiSchemaFieldsPutNestedFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsPutNestedField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsPutNestedFieldOrderingRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	reorderFieldsDto *ReorderFieldsDto
}

// The request that contains the field ids.
func (r ApiSchemaFieldsPutNestedFieldOrderingRequest) ReorderFieldsDto(reorderFieldsDto ReorderFieldsDto) ApiSchemaFieldsPutNestedFieldOrderingRequest {
	r.reorderFieldsDto = &reorderFieldsDto
	return r
}

func (r ApiSchemaFieldsPutNestedFieldOrderingRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsPutNestedFieldOrderingExecute(r)
}

/*
SchemaFieldsPutNestedFieldOrdering Reorder all nested fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @return ApiSchemaFieldsPutNestedFieldOrderingRequest
*/
func (a *SchemasApiService) SchemaFieldsPutNestedFieldOrdering(ctx context.Context, app string, schema string, parentId int64) ApiSchemaFieldsPutNestedFieldOrderingRequest {
	return ApiSchemaFieldsPutNestedFieldOrderingRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsPutNestedFieldOrderingExecute(r ApiSchemaFieldsPutNestedFieldOrderingRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsPutNestedFieldOrdering")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/ordering"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reorderFieldsDto == nil {
		return localVarReturnValue, nil, reportError("reorderFieldsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reorderFieldsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsPutSchemaFieldOrderingRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	reorderFieldsDto *ReorderFieldsDto
}

// The request that contains the field ids.
func (r ApiSchemaFieldsPutSchemaFieldOrderingRequest) ReorderFieldsDto(reorderFieldsDto ReorderFieldsDto) ApiSchemaFieldsPutSchemaFieldOrderingRequest {
	r.reorderFieldsDto = &reorderFieldsDto
	return r
}

func (r ApiSchemaFieldsPutSchemaFieldOrderingRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsPutSchemaFieldOrderingExecute(r)
}

/*
SchemaFieldsPutSchemaFieldOrdering Reorder all fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemaFieldsPutSchemaFieldOrderingRequest
*/
func (a *SchemasApiService) SchemaFieldsPutSchemaFieldOrdering(ctx context.Context, app string, schema string) ApiSchemaFieldsPutSchemaFieldOrderingRequest {
	return ApiSchemaFieldsPutSchemaFieldOrderingRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsPutSchemaFieldOrderingExecute(r ApiSchemaFieldsPutSchemaFieldOrderingRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsPutSchemaFieldOrdering")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/ordering"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reorderFieldsDto == nil {
		return localVarReturnValue, nil, reportError("reorderFieldsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reorderFieldsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsPutSchemaUIFieldsRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	configureUIFieldsDto *ConfigureUIFieldsDto
}

// The request that contains the field names.
func (r ApiSchemaFieldsPutSchemaUIFieldsRequest) ConfigureUIFieldsDto(configureUIFieldsDto ConfigureUIFieldsDto) ApiSchemaFieldsPutSchemaUIFieldsRequest {
	r.configureUIFieldsDto = &configureUIFieldsDto
	return r
}

func (r ApiSchemaFieldsPutSchemaUIFieldsRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsPutSchemaUIFieldsExecute(r)
}

/*
SchemaFieldsPutSchemaUIFields Configure UI fields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemaFieldsPutSchemaUIFieldsRequest
*/
func (a *SchemasApiService) SchemaFieldsPutSchemaUIFields(ctx context.Context, app string, schema string) ApiSchemaFieldsPutSchemaUIFieldsRequest {
	return ApiSchemaFieldsPutSchemaUIFieldsRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsPutSchemaUIFieldsExecute(r ApiSchemaFieldsPutSchemaUIFieldsRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsPutSchemaUIFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/ui"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configureUIFieldsDto == nil {
		return localVarReturnValue, nil, reportError("configureUIFieldsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configureUIFieldsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsShowFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	id int64
}

func (r ApiSchemaFieldsShowFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsShowFieldExecute(r)
}

/*
SchemaFieldsShowField Show a schema field.

A hidden field is not part of the API response, but can still be edited in the portal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param id The id of the field to show.
 @return ApiSchemaFieldsShowFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsShowField(ctx context.Context, app string, schema string, id int64) ApiSchemaFieldsShowFieldRequest {
	return ApiSchemaFieldsShowFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsShowFieldExecute(r ApiSchemaFieldsShowFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsShowField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{id}/show"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemaFieldsShowNestedFieldRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	parentId int64
	id int64
}

func (r ApiSchemaFieldsShowNestedFieldRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemaFieldsShowNestedFieldExecute(r)
}

/*
SchemaFieldsShowNestedField Show a nested field.

A hidden field is not part of the API response, but can still be edited in the portal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @param parentId The parent field id.
 @param id The id of the field to show.
 @return ApiSchemaFieldsShowNestedFieldRequest
*/
func (a *SchemasApiService) SchemaFieldsShowNestedField(ctx context.Context, app string, schema string, parentId int64, id int64) ApiSchemaFieldsShowNestedFieldRequest {
	return ApiSchemaFieldsShowNestedFieldRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
		parentId: parentId,
		id: id,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemaFieldsShowNestedFieldExecute(r ApiSchemaFieldsShowNestedFieldRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemaFieldsShowNestedField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/show"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterToString(r.parentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasDeleteSchemaRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
}

func (r ApiSchemasDeleteSchemaRequest) Execute() (*http.Response, error) {
	return r.ApiService.SchemasDeleteSchemaExecute(r)
}

/*
SchemasDeleteSchema Delete a schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema to delete.
 @return ApiSchemasDeleteSchemaRequest
*/
func (a *SchemasApiService) SchemasDeleteSchema(ctx context.Context, app string, schema string) ApiSchemasDeleteSchemaRequest {
	return ApiSchemasDeleteSchemaRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
func (a *SchemasApiService) SchemasDeleteSchemaExecute(r ApiSchemasDeleteSchemaRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasDeleteSchema")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSchemasGetSchemaRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
}

func (r ApiSchemasGetSchemaRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasGetSchemaExecute(r)
}

/*
SchemasGetSchema Get a schema by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema to retrieve.
 @return ApiSchemasGetSchemaRequest
*/
func (a *SchemasApiService) SchemasGetSchema(ctx context.Context, app string, schema string) ApiSchemasGetSchemaRequest {
	return ApiSchemasGetSchemaRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasGetSchemaExecute(r ApiSchemasGetSchemaRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasGetSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasGetSchemasRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
}

func (r ApiSchemasGetSchemasRequest) Execute() (*SchemasDto, *http.Response, error) {
	return r.ApiService.SchemasGetSchemasExecute(r)
}

/*
SchemasGetSchemas Get schemas.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiSchemasGetSchemasRequest
*/
func (a *SchemasApiService) SchemasGetSchemas(ctx context.Context, app string) ApiSchemasGetSchemasRequest {
	return ApiSchemasGetSchemasRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return SchemasDto
func (a *SchemasApiService) SchemasGetSchemasExecute(r ApiSchemasGetSchemasRequest) (*SchemasDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemasDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasGetSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasPostSchemaRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	createSchemaDto *CreateSchemaDto
}

// The schema object that needs to be added to the app.
func (r ApiSchemasPostSchemaRequest) CreateSchemaDto(createSchemaDto CreateSchemaDto) ApiSchemasPostSchemaRequest {
	r.createSchemaDto = &createSchemaDto
	return r
}

func (r ApiSchemasPostSchemaRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasPostSchemaExecute(r)
}

/*
SchemasPostSchema Create a new schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiSchemasPostSchemaRequest
*/
func (a *SchemasApiService) SchemasPostSchema(ctx context.Context, app string) ApiSchemasPostSchemaRequest {
	return ApiSchemasPostSchemaRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasPostSchemaExecute(r ApiSchemasPostSchemaRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasPostSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSchemaDto == nil {
		return localVarReturnValue, nil, reportError("createSchemaDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSchemaDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasPublishSchemaRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
}

func (r ApiSchemasPublishSchemaRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasPublishSchemaExecute(r)
}

/*
SchemasPublishSchema Publish a schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema to publish.
 @return ApiSchemasPublishSchemaRequest
*/
func (a *SchemasApiService) SchemasPublishSchema(ctx context.Context, app string, schema string) ApiSchemasPublishSchemaRequest {
	return ApiSchemasPublishSchemaRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasPublishSchemaExecute(r ApiSchemasPublishSchemaRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasPublishSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasPutCategoryRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	changeCategoryDto *ChangeCategoryDto
}

// The schema object that needs to updated.
func (r ApiSchemasPutCategoryRequest) ChangeCategoryDto(changeCategoryDto ChangeCategoryDto) ApiSchemasPutCategoryRequest {
	r.changeCategoryDto = &changeCategoryDto
	return r
}

func (r ApiSchemasPutCategoryRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasPutCategoryExecute(r)
}

/*
SchemasPutCategory Update a schema category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemasPutCategoryRequest
*/
func (a *SchemasApiService) SchemasPutCategory(ctx context.Context, app string, schema string) ApiSchemasPutCategoryRequest {
	return ApiSchemasPutCategoryRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasPutCategoryExecute(r ApiSchemasPutCategoryRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasPutCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/category"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.changeCategoryDto == nil {
		return localVarReturnValue, nil, reportError("changeCategoryDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.changeCategoryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasPutPreviewUrlsRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	requestBody *map[string]string
}

// The preview urls for the schema.
func (r ApiSchemasPutPreviewUrlsRequest) RequestBody(requestBody map[string]string) ApiSchemasPutPreviewUrlsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSchemasPutPreviewUrlsRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasPutPreviewUrlsExecute(r)
}

/*
SchemasPutPreviewUrls Update the preview urls.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemasPutPreviewUrlsRequest
*/
func (a *SchemasApiService) SchemasPutPreviewUrls(ctx context.Context, app string, schema string) ApiSchemasPutPreviewUrlsRequest {
	return ApiSchemasPutPreviewUrlsRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasPutPreviewUrlsExecute(r ApiSchemasPutPreviewUrlsRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasPutPreviewUrls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/preview-urls"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasPutRulesRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	configureFieldRulesDto *ConfigureFieldRulesDto
}

// The schema rules object that needs to updated.
func (r ApiSchemasPutRulesRequest) ConfigureFieldRulesDto(configureFieldRulesDto ConfigureFieldRulesDto) ApiSchemasPutRulesRequest {
	r.configureFieldRulesDto = &configureFieldRulesDto
	return r
}

func (r ApiSchemasPutRulesRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasPutRulesExecute(r)
}

/*
SchemasPutRules Update the rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemasPutRulesRequest
*/
func (a *SchemasApiService) SchemasPutRules(ctx context.Context, app string, schema string) ApiSchemasPutRulesRequest {
	return ApiSchemasPutRulesRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasPutRulesExecute(r ApiSchemasPutRulesRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasPutRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configureFieldRulesDto == nil {
		return localVarReturnValue, nil, reportError("configureFieldRulesDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configureFieldRulesDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasPutSchemaRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	updateSchemaDto *UpdateSchemaDto
}

// The schema object that needs to updated.
func (r ApiSchemasPutSchemaRequest) UpdateSchemaDto(updateSchemaDto UpdateSchemaDto) ApiSchemasPutSchemaRequest {
	r.updateSchemaDto = &updateSchemaDto
	return r
}

func (r ApiSchemasPutSchemaRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasPutSchemaExecute(r)
}

/*
SchemasPutSchema Update a schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemasPutSchemaRequest
*/
func (a *SchemasApiService) SchemasPutSchema(ctx context.Context, app string, schema string) ApiSchemasPutSchemaRequest {
	return ApiSchemasPutSchemaRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasPutSchemaExecute(r ApiSchemasPutSchemaRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasPutSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSchemaDto == nil {
		return localVarReturnValue, nil, reportError("updateSchemaDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSchemaDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasPutSchemaSyncRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	synchronizeSchemaDto *SynchronizeSchemaDto
}

// The schema object that needs to updated.
func (r ApiSchemasPutSchemaSyncRequest) SynchronizeSchemaDto(synchronizeSchemaDto SynchronizeSchemaDto) ApiSchemasPutSchemaSyncRequest {
	r.synchronizeSchemaDto = &synchronizeSchemaDto
	return r
}

func (r ApiSchemasPutSchemaSyncRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasPutSchemaSyncExecute(r)
}

/*
SchemasPutSchemaSync Synchronize a schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemasPutSchemaSyncRequest
*/
func (a *SchemasApiService) SchemasPutSchemaSync(ctx context.Context, app string, schema string) ApiSchemasPutSchemaSyncRequest {
	return ApiSchemasPutSchemaSyncRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasPutSchemaSyncExecute(r ApiSchemasPutSchemaSyncRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasPutSchemaSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.synchronizeSchemaDto == nil {
		return localVarReturnValue, nil, reportError("synchronizeSchemaDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.synchronizeSchemaDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasPutScriptsRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
	schemaScriptsDto *SchemaScriptsDto
}

// The schema scripts object that needs to updated.
func (r ApiSchemasPutScriptsRequest) SchemaScriptsDto(schemaScriptsDto SchemaScriptsDto) ApiSchemasPutScriptsRequest {
	r.schemaScriptsDto = &schemaScriptsDto
	return r
}

func (r ApiSchemasPutScriptsRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasPutScriptsExecute(r)
}

/*
SchemasPutScripts Update the scripts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema.
 @return ApiSchemasPutScriptsRequest
*/
func (a *SchemasApiService) SchemasPutScripts(ctx context.Context, app string, schema string) ApiSchemasPutScriptsRequest {
	return ApiSchemasPutScriptsRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasPutScriptsExecute(r ApiSchemasPutScriptsRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasPutScripts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/scripts"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.schemaScriptsDto == nil {
		return localVarReturnValue, nil, reportError("schemaScriptsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schemaScriptsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSchemasUnpublishSchemaRequest struct {
	ctx context.Context
	ApiService *SchemasApiService
	app string
	schema string
}

func (r ApiSchemasUnpublishSchemaRequest) Execute() (*SchemaDto, *http.Response, error) {
	return r.ApiService.SchemasUnpublishSchemaExecute(r)
}

/*
SchemasUnpublishSchema Unpublish a schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param schema The name of the schema to unpublish.
 @return ApiSchemasUnpublishSchemaRequest
*/
func (a *SchemasApiService) SchemasUnpublishSchema(ctx context.Context, app string, schema string) ApiSchemasUnpublishSchemaRequest {
	return ApiSchemasUnpublishSchemaRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		schema: schema,
	}
}

// Execute executes the request
//  @return SchemaDto
func (a *SchemasApiService) SchemasUnpublishSchemaExecute(r ApiSchemasUnpublishSchemaRequest) (*SchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasApiService.SchemasUnpublishSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/schemas/{schema}/unpublish"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schema"+"}", url.PathEscape(parameterToString(r.schema, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
