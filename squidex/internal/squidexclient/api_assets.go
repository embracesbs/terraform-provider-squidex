/*
Squidex API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 7.0.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package squidexclient

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// AssetsApiService AssetsApi service
type AssetsApiService service

type ApiAssetContentGetAssetContentRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	id string
	version *int64
	cache *int64
	download *int32
	width *int32
	height *int32
	quality *int32
	mode *ResizeMode
	bg *string
	focusX *float32
	focusY *float32
	nofocus *bool
	auto *bool
	force *bool
	format *ImageFormat
}

// The optional version of the asset.
func (r ApiAssetContentGetAssetContentRequest) Version(version int64) ApiAssetContentGetAssetContentRequest {
	r.version = &version
	return r
}

// The cache duration in seconds.
func (r ApiAssetContentGetAssetContentRequest) Cache(cache int64) ApiAssetContentGetAssetContentRequest {
	r.cache = &cache
	return r
}

// Set it to 0 to prevent download.
func (r ApiAssetContentGetAssetContentRequest) Download(download int32) ApiAssetContentGetAssetContentRequest {
	r.download = &download
	return r
}

// The target width of the asset, if it is an image.
func (r ApiAssetContentGetAssetContentRequest) Width(width int32) ApiAssetContentGetAssetContentRequest {
	r.width = &width
	return r
}

// The target height of the asset, if it is an image.
func (r ApiAssetContentGetAssetContentRequest) Height(height int32) ApiAssetContentGetAssetContentRequest {
	r.height = &height
	return r
}

// Optional image quality, it is is an jpeg image.
func (r ApiAssetContentGetAssetContentRequest) Quality(quality int32) ApiAssetContentGetAssetContentRequest {
	r.quality = &quality
	return r
}

// The resize mode when the width and height is defined.
func (r ApiAssetContentGetAssetContentRequest) Mode(mode ResizeMode) ApiAssetContentGetAssetContentRequest {
	r.mode = &mode
	return r
}

// Optional background color.
func (r ApiAssetContentGetAssetContentRequest) Bg(bg string) ApiAssetContentGetAssetContentRequest {
	r.bg = &bg
	return r
}

// Override the y focus point.
func (r ApiAssetContentGetAssetContentRequest) FocusX(focusX float32) ApiAssetContentGetAssetContentRequest {
	r.focusX = &focusX
	return r
}

// Override the x focus point.
func (r ApiAssetContentGetAssetContentRequest) FocusY(focusY float32) ApiAssetContentGetAssetContentRequest {
	r.focusY = &focusY
	return r
}

// True to ignore the asset focus point if any.
func (r ApiAssetContentGetAssetContentRequest) Nofocus(nofocus bool) ApiAssetContentGetAssetContentRequest {
	r.nofocus = &nofocus
	return r
}

// True to use auto format.
func (r ApiAssetContentGetAssetContentRequest) Auto(auto bool) ApiAssetContentGetAssetContentRequest {
	r.auto = &auto
	return r
}

// True to force a new resize even if it already stored.
func (r ApiAssetContentGetAssetContentRequest) Force(force bool) ApiAssetContentGetAssetContentRequest {
	r.force = &force
	return r
}

// True to force a new resize even if it already stored.
func (r ApiAssetContentGetAssetContentRequest) Format(format ImageFormat) ApiAssetContentGetAssetContentRequest {
	r.format = &format
	return r
}

func (r ApiAssetContentGetAssetContentRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.AssetContentGetAssetContentExecute(r)
}

/*
AssetContentGetAssetContent Get the asset content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the asset.
 @return ApiAssetContentGetAssetContentRequest

Deprecated
*/
func (a *AssetsApiService) AssetContentGetAssetContent(ctx context.Context, id string) ApiAssetContentGetAssetContentRequest {
	return ApiAssetContentGetAssetContentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
// Deprecated
func (a *AssetsApiService) AssetContentGetAssetContentExecute(r ApiAssetContentGetAssetContentRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetContentGetAssetContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.cache != nil {
		localVarQueryParams.Add("cache", parameterToString(*r.cache, ""))
	}
	if r.download != nil {
		localVarQueryParams.Add("download", parameterToString(*r.download, ""))
	}
	if r.width != nil {
		localVarQueryParams.Add("width", parameterToString(*r.width, ""))
	}
	if r.height != nil {
		localVarQueryParams.Add("height", parameterToString(*r.height, ""))
	}
	if r.quality != nil {
		localVarQueryParams.Add("quality", parameterToString(*r.quality, ""))
	}
	if r.mode != nil {
		localVarQueryParams.Add("mode", parameterToString(*r.mode, ""))
	}
	if r.bg != nil {
		localVarQueryParams.Add("bg", parameterToString(*r.bg, ""))
	}
	if r.focusX != nil {
		localVarQueryParams.Add("focusX", parameterToString(*r.focusX, ""))
	}
	if r.focusY != nil {
		localVarQueryParams.Add("focusY", parameterToString(*r.focusY, ""))
	}
	if r.nofocus != nil {
		localVarQueryParams.Add("nofocus", parameterToString(*r.nofocus, ""))
	}
	if r.auto != nil {
		localVarQueryParams.Add("auto", parameterToString(*r.auto, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetContentGetAssetContentBySlugRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	idOrSlug string
	more string
	version *int64
	cache *int64
	download *int32
	width *int32
	height *int32
	quality *int32
	mode *ResizeMode
	bg *string
	focusX *float32
	focusY *float32
	nofocus *bool
	auto *bool
	force *bool
	format *ImageFormat
}

// The optional version of the asset.
func (r ApiAssetContentGetAssetContentBySlugRequest) Version(version int64) ApiAssetContentGetAssetContentBySlugRequest {
	r.version = &version
	return r
}

// The cache duration in seconds.
func (r ApiAssetContentGetAssetContentBySlugRequest) Cache(cache int64) ApiAssetContentGetAssetContentBySlugRequest {
	r.cache = &cache
	return r
}

// Set it to 0 to prevent download.
func (r ApiAssetContentGetAssetContentBySlugRequest) Download(download int32) ApiAssetContentGetAssetContentBySlugRequest {
	r.download = &download
	return r
}

// The target width of the asset, if it is an image.
func (r ApiAssetContentGetAssetContentBySlugRequest) Width(width int32) ApiAssetContentGetAssetContentBySlugRequest {
	r.width = &width
	return r
}

// The target height of the asset, if it is an image.
func (r ApiAssetContentGetAssetContentBySlugRequest) Height(height int32) ApiAssetContentGetAssetContentBySlugRequest {
	r.height = &height
	return r
}

// Optional image quality, it is is an jpeg image.
func (r ApiAssetContentGetAssetContentBySlugRequest) Quality(quality int32) ApiAssetContentGetAssetContentBySlugRequest {
	r.quality = &quality
	return r
}

// The resize mode when the width and height is defined.
func (r ApiAssetContentGetAssetContentBySlugRequest) Mode(mode ResizeMode) ApiAssetContentGetAssetContentBySlugRequest {
	r.mode = &mode
	return r
}

// Optional background color.
func (r ApiAssetContentGetAssetContentBySlugRequest) Bg(bg string) ApiAssetContentGetAssetContentBySlugRequest {
	r.bg = &bg
	return r
}

// Override the y focus point.
func (r ApiAssetContentGetAssetContentBySlugRequest) FocusX(focusX float32) ApiAssetContentGetAssetContentBySlugRequest {
	r.focusX = &focusX
	return r
}

// Override the x focus point.
func (r ApiAssetContentGetAssetContentBySlugRequest) FocusY(focusY float32) ApiAssetContentGetAssetContentBySlugRequest {
	r.focusY = &focusY
	return r
}

// True to ignore the asset focus point if any.
func (r ApiAssetContentGetAssetContentBySlugRequest) Nofocus(nofocus bool) ApiAssetContentGetAssetContentBySlugRequest {
	r.nofocus = &nofocus
	return r
}

// True to use auto format.
func (r ApiAssetContentGetAssetContentBySlugRequest) Auto(auto bool) ApiAssetContentGetAssetContentBySlugRequest {
	r.auto = &auto
	return r
}

// True to force a new resize even if it already stored.
func (r ApiAssetContentGetAssetContentBySlugRequest) Force(force bool) ApiAssetContentGetAssetContentBySlugRequest {
	r.force = &force
	return r
}

// True to force a new resize even if it already stored.
func (r ApiAssetContentGetAssetContentBySlugRequest) Format(format ImageFormat) ApiAssetContentGetAssetContentBySlugRequest {
	r.format = &format
	return r
}

func (r ApiAssetContentGetAssetContentBySlugRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.AssetContentGetAssetContentBySlugExecute(r)
}

/*
AssetContentGetAssetContentBySlug Get the asset content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param idOrSlug The id or slug of the asset.
 @param more Optional suffix that can be used to seo-optimize the link to the image Has not effect.
 @return ApiAssetContentGetAssetContentBySlugRequest
*/
func (a *AssetsApiService) AssetContentGetAssetContentBySlug(ctx context.Context, app string, idOrSlug string, more string) ApiAssetContentGetAssetContentBySlugRequest {
	return ApiAssetContentGetAssetContentBySlugRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		idOrSlug: idOrSlug,
		more: more,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AssetsApiService) AssetContentGetAssetContentBySlugExecute(r ApiAssetContentGetAssetContentBySlugRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetContentGetAssetContentBySlug")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assets/{app}/{idOrSlug}/{more}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"idOrSlug"+"}", url.PathEscape(parameterToString(r.idOrSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"more"+"}", url.PathEscape(parameterToString(r.more, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.cache != nil {
		localVarQueryParams.Add("cache", parameterToString(*r.cache, ""))
	}
	if r.download != nil {
		localVarQueryParams.Add("download", parameterToString(*r.download, ""))
	}
	if r.width != nil {
		localVarQueryParams.Add("width", parameterToString(*r.width, ""))
	}
	if r.height != nil {
		localVarQueryParams.Add("height", parameterToString(*r.height, ""))
	}
	if r.quality != nil {
		localVarQueryParams.Add("quality", parameterToString(*r.quality, ""))
	}
	if r.mode != nil {
		localVarQueryParams.Add("mode", parameterToString(*r.mode, ""))
	}
	if r.bg != nil {
		localVarQueryParams.Add("bg", parameterToString(*r.bg, ""))
	}
	if r.focusX != nil {
		localVarQueryParams.Add("focusX", parameterToString(*r.focusX, ""))
	}
	if r.focusY != nil {
		localVarQueryParams.Add("focusY", parameterToString(*r.focusY, ""))
	}
	if r.nofocus != nil {
		localVarQueryParams.Add("nofocus", parameterToString(*r.nofocus, ""))
	}
	if r.auto != nil {
		localVarQueryParams.Add("auto", parameterToString(*r.auto, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetFoldersDeleteAssetFolderRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
}

func (r ApiAssetFoldersDeleteAssetFolderRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssetFoldersDeleteAssetFolderExecute(r)
}

/*
AssetFoldersDeleteAssetFolder Delete an asset folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The id of the asset folder to delete.
 @return ApiAssetFoldersDeleteAssetFolderRequest
*/
func (a *AssetsApiService) AssetFoldersDeleteAssetFolder(ctx context.Context, app string, id string) ApiAssetFoldersDeleteAssetFolderRequest {
	return ApiAssetFoldersDeleteAssetFolderRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
func (a *AssetsApiService) AssetFoldersDeleteAssetFolderExecute(r ApiAssetFoldersDeleteAssetFolderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetFoldersDeleteAssetFolder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/folders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssetFoldersGetAssetFoldersRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	parentId *string
	scope *AssetFolderScope
}

// The optional parent folder id.
func (r ApiAssetFoldersGetAssetFoldersRequest) ParentId(parentId string) ApiAssetFoldersGetAssetFoldersRequest {
	r.parentId = &parentId
	return r
}

// The scope of the query.
func (r ApiAssetFoldersGetAssetFoldersRequest) Scope(scope AssetFolderScope) ApiAssetFoldersGetAssetFoldersRequest {
	r.scope = &scope
	return r
}

func (r ApiAssetFoldersGetAssetFoldersRequest) Execute() (*AssetFoldersDto, *http.Response, error) {
	return r.ApiService.AssetFoldersGetAssetFoldersExecute(r)
}

/*
AssetFoldersGetAssetFolders Get asset folders.

Get all asset folders for the app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiAssetFoldersGetAssetFoldersRequest
*/
func (a *AssetsApiService) AssetFoldersGetAssetFolders(ctx context.Context, app string) ApiAssetFoldersGetAssetFoldersRequest {
	return ApiAssetFoldersGetAssetFoldersRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return AssetFoldersDto
func (a *AssetsApiService) AssetFoldersGetAssetFoldersExecute(r ApiAssetFoldersGetAssetFoldersRequest) (*AssetFoldersDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetFoldersDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetFoldersGetAssetFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/folders"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parentId != nil {
		localVarQueryParams.Add("parentId", parameterToString(*r.parentId, ""))
	}
	if r.scope != nil {
		localVarQueryParams.Add("scope", parameterToString(*r.scope, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetFoldersPostAssetFolderRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	createAssetFolderDto *CreateAssetFolderDto
}

// The asset folder object that needs to be added to the App.
func (r ApiAssetFoldersPostAssetFolderRequest) CreateAssetFolderDto(createAssetFolderDto CreateAssetFolderDto) ApiAssetFoldersPostAssetFolderRequest {
	r.createAssetFolderDto = &createAssetFolderDto
	return r
}

func (r ApiAssetFoldersPostAssetFolderRequest) Execute() (*AssetFolderDto, *http.Response, error) {
	return r.ApiService.AssetFoldersPostAssetFolderExecute(r)
}

/*
AssetFoldersPostAssetFolder Create an asset folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiAssetFoldersPostAssetFolderRequest
*/
func (a *AssetsApiService) AssetFoldersPostAssetFolder(ctx context.Context, app string) ApiAssetFoldersPostAssetFolderRequest {
	return ApiAssetFoldersPostAssetFolderRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return AssetFolderDto
func (a *AssetsApiService) AssetFoldersPostAssetFolderExecute(r ApiAssetFoldersPostAssetFolderRequest) (*AssetFolderDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetFolderDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetFoldersPostAssetFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/folders"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAssetFolderDto == nil {
		return localVarReturnValue, nil, reportError("createAssetFolderDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetFolderDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetFoldersPutAssetFolderRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
	renameAssetFolderDto *RenameAssetFolderDto
}

// The asset folder object that needs to updated.
func (r ApiAssetFoldersPutAssetFolderRequest) RenameAssetFolderDto(renameAssetFolderDto RenameAssetFolderDto) ApiAssetFoldersPutAssetFolderRequest {
	r.renameAssetFolderDto = &renameAssetFolderDto
	return r
}

func (r ApiAssetFoldersPutAssetFolderRequest) Execute() (*AssetFolderDto, *http.Response, error) {
	return r.ApiService.AssetFoldersPutAssetFolderExecute(r)
}

/*
AssetFoldersPutAssetFolder Update an asset folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The id of the asset folder.
 @return ApiAssetFoldersPutAssetFolderRequest
*/
func (a *AssetsApiService) AssetFoldersPutAssetFolder(ctx context.Context, app string, id string) ApiAssetFoldersPutAssetFolderRequest {
	return ApiAssetFoldersPutAssetFolderRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
//  @return AssetFolderDto
func (a *AssetsApiService) AssetFoldersPutAssetFolderExecute(r ApiAssetFoldersPutAssetFolderRequest) (*AssetFolderDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetFolderDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetFoldersPutAssetFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/folders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.renameAssetFolderDto == nil {
		return localVarReturnValue, nil, reportError("renameAssetFolderDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.renameAssetFolderDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetFoldersPutAssetFolderParentRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
	moveAssetFolderDto *MoveAssetFolderDto
}

// The asset folder object that needs to updated.
func (r ApiAssetFoldersPutAssetFolderParentRequest) MoveAssetFolderDto(moveAssetFolderDto MoveAssetFolderDto) ApiAssetFoldersPutAssetFolderParentRequest {
	r.moveAssetFolderDto = &moveAssetFolderDto
	return r
}

func (r ApiAssetFoldersPutAssetFolderParentRequest) Execute() (*AssetFolderDto, *http.Response, error) {
	return r.ApiService.AssetFoldersPutAssetFolderParentExecute(r)
}

/*
AssetFoldersPutAssetFolderParent Move an asset folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The id of the asset folder.
 @return ApiAssetFoldersPutAssetFolderParentRequest
*/
func (a *AssetsApiService) AssetFoldersPutAssetFolderParent(ctx context.Context, app string, id string) ApiAssetFoldersPutAssetFolderParentRequest {
	return ApiAssetFoldersPutAssetFolderParentRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
//  @return AssetFolderDto
func (a *AssetsApiService) AssetFoldersPutAssetFolderParentExecute(r ApiAssetFoldersPutAssetFolderParentRequest) (*AssetFolderDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetFolderDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetFoldersPutAssetFolderParent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/folders/{id}/parent"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveAssetFolderDto == nil {
		return localVarReturnValue, nil, reportError("moveAssetFolderDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveAssetFolderDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsBulkUpdateAssetsRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	bulkUpdateAssetsDto *BulkUpdateAssetsDto
}

// The bulk update request.
func (r ApiAssetsBulkUpdateAssetsRequest) BulkUpdateAssetsDto(bulkUpdateAssetsDto BulkUpdateAssetsDto) ApiAssetsBulkUpdateAssetsRequest {
	r.bulkUpdateAssetsDto = &bulkUpdateAssetsDto
	return r
}

func (r ApiAssetsBulkUpdateAssetsRequest) Execute() ([]BulkResultDto, *http.Response, error) {
	return r.ApiService.AssetsBulkUpdateAssetsExecute(r)
}

/*
AssetsBulkUpdateAssets Bulk update assets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiAssetsBulkUpdateAssetsRequest
*/
func (a *AssetsApiService) AssetsBulkUpdateAssets(ctx context.Context, app string) ApiAssetsBulkUpdateAssetsRequest {
	return ApiAssetsBulkUpdateAssetsRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return []BulkResultDto
func (a *AssetsApiService) AssetsBulkUpdateAssetsExecute(r ApiAssetsBulkUpdateAssetsRequest) ([]BulkResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BulkResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsBulkUpdateAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkUpdateAssetsDto == nil {
		return localVarReturnValue, nil, reportError("bulkUpdateAssetsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkUpdateAssetsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsDeleteAssetRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
	checkReferrers *bool
	permanent *bool
}

// True to check referrers of this asset.
func (r ApiAssetsDeleteAssetRequest) CheckReferrers(checkReferrers bool) ApiAssetsDeleteAssetRequest {
	r.checkReferrers = &checkReferrers
	return r
}

// True to delete the asset permanently.
func (r ApiAssetsDeleteAssetRequest) Permanent(permanent bool) ApiAssetsDeleteAssetRequest {
	r.permanent = &permanent
	return r
}

func (r ApiAssetsDeleteAssetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssetsDeleteAssetExecute(r)
}

/*
AssetsDeleteAsset Delete an asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The id of the asset to delete.
 @return ApiAssetsDeleteAssetRequest
*/
func (a *AssetsApiService) AssetsDeleteAsset(ctx context.Context, app string, id string) ApiAssetsDeleteAssetRequest {
	return ApiAssetsDeleteAssetRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
func (a *AssetsApiService) AssetsDeleteAssetExecute(r ApiAssetsDeleteAssetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsDeleteAsset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.checkReferrers != nil {
		localVarQueryParams.Add("CheckReferrers", parameterToString(*r.checkReferrers, ""))
	}
	if r.permanent != nil {
		localVarQueryParams.Add("Permanent", parameterToString(*r.permanent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssetsGetAssetRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
}

func (r ApiAssetsGetAssetRequest) Execute() (*AssetDto, *http.Response, error) {
	return r.ApiService.AssetsGetAssetExecute(r)
}

/*
AssetsGetAsset Get an asset by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The id of the asset to retrieve.
 @return ApiAssetsGetAssetRequest
*/
func (a *AssetsApiService) AssetsGetAsset(ctx context.Context, app string, id string) ApiAssetsGetAssetRequest {
	return ApiAssetsGetAssetRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
//  @return AssetDto
func (a *AssetsApiService) AssetsGetAssetExecute(r ApiAssetsGetAssetRequest) (*AssetDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsGetAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsGetAssetsRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	parentId *string
	ids *string
	q *string
	top *float32
	skip *float32
	orderby *string
	filter *string
}

// The optional parent folder id.
func (r ApiAssetsGetAssetsRequest) ParentId(parentId string) ApiAssetsGetAssetsRequest {
	r.parentId = &parentId
	return r
}

// The optional asset ids.
func (r ApiAssetsGetAssetsRequest) Ids(ids string) ApiAssetsGetAssetsRequest {
	r.ids = &ids
	return r
}

// The optional json query.
func (r ApiAssetsGetAssetsRequest) Q(q string) ApiAssetsGetAssetsRequest {
	r.q = &q
	return r
}

// Optional number of contents to take.
func (r ApiAssetsGetAssetsRequest) Top(top float32) ApiAssetsGetAssetsRequest {
	r.top = &top
	return r
}

// Optional number of contents to skip.
func (r ApiAssetsGetAssetsRequest) Skip(skip float32) ApiAssetsGetAssetsRequest {
	r.skip = &skip
	return r
}

// Optional OData order definition.
func (r ApiAssetsGetAssetsRequest) Orderby(orderby string) ApiAssetsGetAssetsRequest {
	r.orderby = &orderby
	return r
}

// Optional OData filter.
func (r ApiAssetsGetAssetsRequest) Filter(filter string) ApiAssetsGetAssetsRequest {
	r.filter = &filter
	return r
}

func (r ApiAssetsGetAssetsRequest) Execute() (*AssetsDto, *http.Response, error) {
	return r.ApiService.AssetsGetAssetsExecute(r)
}

/*
AssetsGetAssets Get assets.

Get all assets for the app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiAssetsGetAssetsRequest
*/
func (a *AssetsApiService) AssetsGetAssets(ctx context.Context, app string) ApiAssetsGetAssetsRequest {
	return ApiAssetsGetAssetsRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return AssetsDto
func (a *AssetsApiService) AssetsGetAssetsExecute(r ApiAssetsGetAssetsRequest) (*AssetsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsGetAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parentId != nil {
		localVarQueryParams.Add("parentId", parameterToString(*r.parentId, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsGetAssetsPostRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	queryDto *QueryDto
}

// The required query object.
func (r ApiAssetsGetAssetsPostRequest) QueryDto(queryDto QueryDto) ApiAssetsGetAssetsPostRequest {
	r.queryDto = &queryDto
	return r
}

func (r ApiAssetsGetAssetsPostRequest) Execute() (*AssetsDto, *http.Response, error) {
	return r.ApiService.AssetsGetAssetsPostExecute(r)
}

/*
AssetsGetAssetsPost Get assets.

Get all assets for the app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiAssetsGetAssetsPostRequest
*/
func (a *AssetsApiService) AssetsGetAssetsPost(ctx context.Context, app string) ApiAssetsGetAssetsPostRequest {
	return ApiAssetsGetAssetsPostRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return AssetsDto
func (a *AssetsApiService) AssetsGetAssetsPostExecute(r ApiAssetsGetAssetsPostRequest) (*AssetsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsGetAssetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/query"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryDto == nil {
		return localVarReturnValue, nil, reportError("queryDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsGetTagsRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
}

func (r ApiAssetsGetTagsRequest) Execute() (map[string]int32, *http.Response, error) {
	return r.ApiService.AssetsGetTagsExecute(r)
}

/*
AssetsGetTags Get assets tags.

Get all tags for assets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiAssetsGetTagsRequest
*/
func (a *AssetsApiService) AssetsGetTags(ctx context.Context, app string) ApiAssetsGetTagsRequest {
	return ApiAssetsGetTagsRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return map[string]int32
func (a *AssetsApiService) AssetsGetTagsExecute(r ApiAssetsGetTagsRequest) (map[string]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsGetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsPostAssetRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	parentId *string
	id *string
	duplicate *bool
	file **os.File
}

// The optional parent folder id.
func (r ApiAssetsPostAssetRequest) ParentId(parentId string) ApiAssetsPostAssetRequest {
	r.parentId = &parentId
	return r
}

// The optional custom asset id.
func (r ApiAssetsPostAssetRequest) Id(id string) ApiAssetsPostAssetRequest {
	r.id = &id
	return r
}

// True to duplicate the asset, event if the file has been uploaded.
func (r ApiAssetsPostAssetRequest) Duplicate(duplicate bool) ApiAssetsPostAssetRequest {
	r.duplicate = &duplicate
	return r
}

func (r ApiAssetsPostAssetRequest) File(file *os.File) ApiAssetsPostAssetRequest {
	r.file = &file
	return r
}

func (r ApiAssetsPostAssetRequest) Execute() (*AssetDto, *http.Response, error) {
	return r.ApiService.AssetsPostAssetExecute(r)
}

/*
AssetsPostAsset Upload a new asset.

You can only upload one file at a time. The mime type of the file is not calculated by Squidex and is required correctly.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @return ApiAssetsPostAssetRequest
*/
func (a *AssetsApiService) AssetsPostAsset(ctx context.Context, app string) ApiAssetsPostAssetRequest {
	return ApiAssetsPostAssetRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
	}
}

// Execute executes the request
//  @return AssetDto
func (a *AssetsApiService) AssetsPostAssetExecute(r ApiAssetsPostAssetRequest) (*AssetDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsPostAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parentId != nil {
		localVarQueryParams.Add("ParentId", parameterToString(*r.parentId, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("Id", parameterToString(*r.id, ""))
	}
	if r.duplicate != nil {
		localVarQueryParams.Add("Duplicate", parameterToString(*r.duplicate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "File"

	var fileLocalVarFile *os.File
	if r.file != nil {
		fileLocalVarFile = *r.file
	}
	if fileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileLocalVarFile)
		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsPostUpsertAssetRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
	parentId *string
	duplicate *bool
	file **os.File
}

// The optional parent folder id.
func (r ApiAssetsPostUpsertAssetRequest) ParentId(parentId string) ApiAssetsPostUpsertAssetRequest {
	r.parentId = &parentId
	return r
}

// True to duplicate the asset, event if the file has been uploaded.
func (r ApiAssetsPostUpsertAssetRequest) Duplicate(duplicate bool) ApiAssetsPostUpsertAssetRequest {
	r.duplicate = &duplicate
	return r
}

func (r ApiAssetsPostUpsertAssetRequest) File(file *os.File) ApiAssetsPostUpsertAssetRequest {
	r.file = &file
	return r
}

func (r ApiAssetsPostUpsertAssetRequest) Execute() (*AssetDto, *http.Response, error) {
	return r.ApiService.AssetsPostUpsertAssetExecute(r)
}

/*
AssetsPostUpsertAsset Upsert an asset.

You can only upload one file at a time. The mime type of the file is not calculated by Squidex and is required correctly.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The optional custom asset id.
 @return ApiAssetsPostUpsertAssetRequest
*/
func (a *AssetsApiService) AssetsPostUpsertAsset(ctx context.Context, app string, id string) ApiAssetsPostUpsertAssetRequest {
	return ApiAssetsPostUpsertAssetRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
//  @return AssetDto
func (a *AssetsApiService) AssetsPostUpsertAssetExecute(r ApiAssetsPostUpsertAssetRequest) (*AssetDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsPostUpsertAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parentId != nil {
		localVarQueryParams.Add("ParentId", parameterToString(*r.parentId, ""))
	}
	if r.duplicate != nil {
		localVarQueryParams.Add("Duplicate", parameterToString(*r.duplicate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "File"

	var fileLocalVarFile *os.File
	if r.file != nil {
		fileLocalVarFile = *r.file
	}
	if fileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileLocalVarFile)
		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsPutAssetRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
	annotateAssetDto *AnnotateAssetDto
}

// The asset object that needs to updated.
func (r ApiAssetsPutAssetRequest) AnnotateAssetDto(annotateAssetDto AnnotateAssetDto) ApiAssetsPutAssetRequest {
	r.annotateAssetDto = &annotateAssetDto
	return r
}

func (r ApiAssetsPutAssetRequest) Execute() (*AssetDto, *http.Response, error) {
	return r.ApiService.AssetsPutAssetExecute(r)
}

/*
AssetsPutAsset Update an asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The id of the asset.
 @return ApiAssetsPutAssetRequest
*/
func (a *AssetsApiService) AssetsPutAsset(ctx context.Context, app string, id string) ApiAssetsPutAssetRequest {
	return ApiAssetsPutAssetRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
//  @return AssetDto
func (a *AssetsApiService) AssetsPutAssetExecute(r ApiAssetsPutAssetRequest) (*AssetDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsPutAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.annotateAssetDto == nil {
		return localVarReturnValue, nil, reportError("annotateAssetDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.annotateAssetDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsPutAssetContentRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
	file **os.File
}

func (r ApiAssetsPutAssetContentRequest) File(file *os.File) ApiAssetsPutAssetContentRequest {
	r.file = &file
	return r
}

func (r ApiAssetsPutAssetContentRequest) Execute() (*AssetDto, *http.Response, error) {
	return r.ApiService.AssetsPutAssetContentExecute(r)
}

/*
AssetsPutAssetContent Replace asset content.

Use multipart request to upload an asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The id of the asset.
 @return ApiAssetsPutAssetContentRequest
*/
func (a *AssetsApiService) AssetsPutAssetContent(ctx context.Context, app string, id string) ApiAssetsPutAssetContentRequest {
	return ApiAssetsPutAssetContentRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
//  @return AssetDto
func (a *AssetsApiService) AssetsPutAssetContentExecute(r ApiAssetsPutAssetContentRequest) (*AssetDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsPutAssetContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/{id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"

	var fileLocalVarFile *os.File
	if r.file != nil {
		fileLocalVarFile = *r.file
	}
	if fileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileLocalVarFile)
		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsPutAssetParentRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	id string
	moveAssetDto *MoveAssetDto
}

// The asset object that needs to updated.
func (r ApiAssetsPutAssetParentRequest) MoveAssetDto(moveAssetDto MoveAssetDto) ApiAssetsPutAssetParentRequest {
	r.moveAssetDto = &moveAssetDto
	return r
}

func (r ApiAssetsPutAssetParentRequest) Execute() (*AssetDto, *http.Response, error) {
	return r.ApiService.AssetsPutAssetParentExecute(r)
}

/*
AssetsPutAssetParent Moves the asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param id The id of the asset.
 @return ApiAssetsPutAssetParentRequest
*/
func (a *AssetsApiService) AssetsPutAssetParent(ctx context.Context, app string, id string) ApiAssetsPutAssetParentRequest {
	return ApiAssetsPutAssetParentRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		id: id,
	}
}

// Execute executes the request
//  @return AssetDto
func (a *AssetsApiService) AssetsPutAssetParentExecute(r ApiAssetsPutAssetParentRequest) (*AssetDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsPutAssetParent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/{id}/parent"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveAssetDto == nil {
		return localVarReturnValue, nil, reportError("moveAssetDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveAssetDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetsPutTagRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	app string
	name string
	renameTagDto *RenameTagDto
}

// The required request object.
func (r ApiAssetsPutTagRequest) RenameTagDto(renameTagDto RenameTagDto) ApiAssetsPutTagRequest {
	r.renameTagDto = &renameTagDto
	return r
}

func (r ApiAssetsPutTagRequest) Execute() (map[string]int32, *http.Response, error) {
	return r.ApiService.AssetsPutTagExecute(r)
}

/*
AssetsPutTag Rename an asset tag.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param app The name of the app.
 @param name The tag to return.
 @return ApiAssetsPutTagRequest
*/
func (a *AssetsApiService) AssetsPutTag(ctx context.Context, app string, name string) ApiAssetsPutTagRequest {
	return ApiAssetsPutTagRequest{
		ApiService: a,
		ctx: ctx,
		app: app,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]int32
func (a *AssetsApiService) AssetsPutTagExecute(r ApiAssetsPutTagRequest) (map[string]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.AssetsPutTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apps/{app}/assets/tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterToString(r.app, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.renameTagDto == nil {
		return localVarReturnValue, nil, reportError("renameTagDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.renameTagDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
